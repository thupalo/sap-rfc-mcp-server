{
  "current_analysis": {
    "server_files": [
      "sap_rfc_mcp_server/server.py",
      "sap_rfc_mcp_server/http_server.py",
      "sap_rfc_mcp_server/sap_client.py",
      "sap_rfc_mcp_server/metadata_manager.py",
      "sap_rfc_mcp_server/rfc_table_reader.py"
    ],
    "total_lines": 2214,
    "tools_count": 0,
    "tools": {}
  },
  "optimization_opportunities": {
    "data_processing": [],
    "business_logic": [],
    "caching": [],
    "validation": [],
    "formatting": []
  },
  "minimal_server_design": {
    "core_server_functions": [
      "RFC connection management",
      "Basic RFC function calls",
      "Error handling and logging",
      "MCP protocol compliance"
    ],
    "client_side_functions": [
      "Data formatting and transformation",
      "Business logic processing",
      "Caching and optimization",
      "Complex queries and filtering",
      "Export and reporting",
      "Validation and preprocessing"
    ],
    "interface_design": {
      "server_tools": [
        {
          "name": "call_rfc_function",
          "description": "Direct RFC function call - minimal processing",
          "complexity": "low"
        },
        {
          "name": "get_connection_info",
          "description": "SAP system information",
          "complexity": "low"
        },
        {
          "name": "list_available_functions",
          "description": "Basic function enumeration",
          "complexity": "low"
        }
      ],
      "client_utilities": [
        {
          "name": "RFCMetadataClient",
          "description": "Client-side metadata management",
          "functions": [
            "caching",
            "search",
            "export"
          ]
        },
        {
          "name": "RFCTableClient",
          "description": "Client-side table operations",
          "functions": [
            "pagination",
            "filtering",
            "formatting"
          ]
        },
        {
          "name": "RFCQueryBuilder",
          "description": "Client-side query construction",
          "functions": [
            "validation",
            "optimization",
            "templating"
          ]
        }
      ]
    }
  },
  "recommended_architecture": {
    "server_responsibilities": [
      "MCP protocol handling",
      "SAP RFC connection management",
      "Basic RFC function calls",
      "Connection status and health"
    ],
    "client_responsibilities": [
      "Data processing and transformation",
      "Metadata caching and search",
      "Business logic and validation",
      "Complex query optimization",
      "Export and formatting operations"
    ]
  },
  "implementation": {
    "minimal_server_code": "#!/usr/bin/env python3\n\"\"\"\nMinimal MCP Server for SAP RFC - STDIO Transport\nFocuses on core MCP protocol and basic RFC connectivity.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nfrom typing import Any, Dict, List\n\nimport mcp.server.stdio\nfrom mcp.server import Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.types import TextContent, Tool\n\nfrom .sap_client import SAPRFCManager, SAPConnectionError\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Create MCP server\nserver = Server(\"sap-rfc-minimal-server\")\n\n# Global SAP client\nsap_client = None\n\ndef _get_sap_client():\n    \"\"\"Get or create SAP client instance.\"\"\"\n    global sap_client\n    if sap_client is None:\n        sap_client = SAPRFCManager()\n    return sap_client\n\n@server.list_tools()\nasync def handle_list_tools() -> list[Tool]:\n    \"\"\"List minimal set of SAP RFC tools.\"\"\"\n    return [\n        Tool(\n            name=\"call_rfc_function\",\n            description=\"Call any RFC function with parameters - raw results\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"function_name\": {\n                        \"type\": \"string\",\n                        \"description\": \"Name of the RFC function to call\"\n                    },\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"description\": \"Function parameters as key-value pairs\"\n                    }\n                },\n                \"required\": [\"function_name\"]\n            }\n        ),\n        Tool(\n            name=\"get_system_info\",\n            description=\"Get basic SAP system information\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }\n        ),\n        Tool(\n            name=\"ping_connection\",\n            description=\"Test SAP connection status\",\n            inputSchema={\n                \"type\": \"object\", \n                \"properties\": {},\n                \"required\": []\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def handle_call_tool(name: str, arguments: dict) -> list[TextContent]:\n    \"\"\"Handle tool calls with minimal processing.\"\"\"\n    try:\n        client = _get_sap_client()\n        \n        if name == \"call_rfc_function\":\n            function_name = arguments[\"function_name\"]\n            parameters = arguments.get(\"parameters\", {})\n            \n            # Direct RFC call - no processing\n            result = await asyncio.get_event_loop().run_in_executor(\n                None, client.call_rfc_function, function_name, **parameters\n            )\n            \n            return [TextContent(\n                type=\"text\", \n                text=json.dumps(result, indent=2, ensure_ascii=False)\n            )]\n            \n        elif name == \"get_system_info\":\n            result = await asyncio.get_event_loop().run_in_executor(\n                None, client.get_system_info\n            )\n            return [TextContent(type=\"text\", text=json.dumps(result, indent=2))]\n            \n        elif name == \"ping_connection\":\n            # Simple connection test\n            try:\n                await asyncio.get_event_loop().run_in_executor(\n                    None, client.get_system_info\n                )\n                result = {\"status\": \"connected\", \"timestamp\": str(asyncio.get_event_loop().time())}\n            except Exception as e:\n                result = {\"status\": \"disconnected\", \"error\": str(e)}\n                \n            return [TextContent(type=\"text\", text=json.dumps(result, indent=2))]\n            \n        else:\n            raise ValueError(f\"Unknown tool: {name}\")\n            \n    except SAPConnectionError as e:\n        return [TextContent(type=\"text\", text=f\"SAP Connection Error: {str(e)}\")]\n    except Exception as e:\n        logger.error(f\"Error in tool {name}: {e}\")\n        return [TextContent(type=\"text\", text=f\"Error: {str(e)}\")]\n\nasync def main():\n    \"\"\"Main entry point for the minimal MCP server.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"sap-rfc-minimal-server\",\n                server_version=\"1.0.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=mcp.server.NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
    "client_utilities": {
      "rfc_metadata_client.py": "\"\"\"\nClient-side RFC Metadata Management\nHandles caching, searching, and processing of SAP RFC metadata.\n\"\"\"\n\nimport json\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\n\n\nclass RFCMetadataClient:\n    \"\"\"Client-side RFC metadata management with local caching.\"\"\"\n    \n    def __init__(self, cache_dir: str = \"cache\", mcp_client=None):\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n        self.mcp_client = mcp_client\n        self.db_path = self.cache_dir / \"rfc_metadata.db\"\n        self._init_cache_db()\n    \n    def _init_cache_db(self):\n        \"\"\"Initialize SQLite cache database.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS function_metadata (\n                function_name TEXT PRIMARY KEY,\n                metadata TEXT,\n                language TEXT,\n                cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS search_index (\n                function_name TEXT,\n                search_text TEXT,\n                FOREIGN KEY (function_name) REFERENCES function_metadata(function_name)\n            )\n        \"\"\")\n        conn.commit()\n        conn.close()\n    \n    async def get_function_metadata(self, function_name: str, language: str = \"EN\") -> Dict:\n        \"\"\"Get function metadata with client-side caching.\"\"\"\n        # Check cache first\n        cached = self._get_cached_metadata(function_name, language)\n        if cached:\n            return cached\n            \n        # Fetch from server via MCP\n        if self.mcp_client:\n            raw_result = await self.mcp_client.call_tool(\"call_rfc_function\", {\n                \"function_name\": \"RFC_GET_FUNCTION_INTERFACE\",\n                \"parameters\": {\"FUNCNAME\": function_name, \"LANGUAGE\": language}\n            })\n            \n            # Process and cache the result\n            processed = self._process_metadata(raw_result, function_name, language)\n            self._cache_metadata(function_name, language, processed)\n            return processed\n            \n        return {}\n    \n    def search_functions(self, query: str, limit: int = 20) -> List[Dict]:\n        \"\"\"Client-side function search using local index.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        results = conn.execute(\"\"\"\n            SELECT DISTINCT f.function_name, f.metadata \n            FROM function_metadata f\n            JOIN search_index s ON f.function_name = s.function_name\n            WHERE s.search_text LIKE ? \n            LIMIT ?\n        \"\"\", (f\"%{query.lower()}%\", limit)).fetchall()\n        conn.close()\n        \n        return [{\"name\": name, \"metadata\": json.loads(metadata)} \n                for name, metadata in results]\n    \n    def _get_cached_metadata(self, function_name: str, language: str) -> Optional[Dict]:\n        \"\"\"Get metadata from cache.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        result = conn.execute(\n            \"SELECT metadata FROM function_metadata WHERE function_name = ? AND language = ?\",\n            (function_name, language)\n        ).fetchone()\n        conn.close()\n        \n        return json.loads(result[0]) if result else None\n    \n    def _cache_metadata(self, function_name: str, language: str, metadata: Dict):\n        \"\"\"Cache metadata and update search index.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        \n        # Cache metadata\n        conn.execute(\"\"\"\n            INSERT OR REPLACE INTO function_metadata (function_name, metadata, language)\n            VALUES (?, ?, ?)\n        \"\"\", (function_name, json.dumps(metadata), language))\n        \n        # Update search index\n        search_text = \" \".join([\n            function_name.lower(),\n            metadata.get(\"description\", \"\").lower(),\n            \" \".join(p.get(\"name\", \"\") for p in metadata.get(\"parameters\", []))\n        ])\n        \n        conn.execute(\"DELETE FROM search_index WHERE function_name = ?\", (function_name,))\n        conn.execute(\"INSERT INTO search_index (function_name, search_text) VALUES (?, ?)\",\n                    (function_name, search_text))\n        \n        conn.commit()\n        conn.close()\n    \n    def _process_metadata(self, raw_result: Dict, function_name: str, language: str) -> Dict:\n        \"\"\"Process raw RFC metadata into structured format.\"\"\"\n        # Client-side processing logic here\n        return {\n            \"function_name\": function_name,\n            \"language\": language,\n            \"description\": \"Processed description\",\n            \"parameters\": [],\n            \"processed_by\": \"client\"\n        }\n",
      "rfc_table_client.py": "\"\"\"\nClient-side RFC Table Operations\nHandles table reading, pagination, and data processing.\n\"\"\"\n\nimport json\nfrom typing import Dict, List, Optional, Any\n\n\nclass RFCTableClient:\n    \"\"\"Client-side table operations with smart chunking and processing.\"\"\"\n    \n    def __init__(self, mcp_client=None):\n        self.mcp_client = mcp_client\n        self.chunk_size = 1000  # Default chunk size\n        \n    async def read_table_smart(self, \n                              table_name: str,\n                              fields: List[str] = None,\n                              where_conditions: List[str] = None,\n                              max_rows: int = 10000) -> Dict[str, Any]:\n        \"\"\"Smart table reading with client-side optimization.\"\"\"\n        \n        # Client-side field optimization\n        if fields:\n            fields = self._optimize_field_selection(table_name, fields)\n        \n        # Client-side where clause optimization  \n        if where_conditions:\n            where_conditions = self._optimize_where_conditions(where_conditions)\n            \n        # Chunked reading for large datasets\n        all_data = []\n        rows_read = 0\n        skip_rows = 0\n        \n        while rows_read < max_rows:\n            chunk_size = min(self.chunk_size, max_rows - rows_read)\n            \n            # Call minimal server function\n            chunk_result = await self.mcp_client.call_tool(\"call_rfc_function\", {\n                \"function_name\": \"RFC_READ_TABLE\",\n                \"parameters\": {\n                    \"QUERY_TABLE\": table_name,\n                    \"DELIMITER\": \"|\",\n                    \"FIELDS\": [{\"FIELDNAME\": f} for f in (fields or [])],\n                    \"OPTIONS\": [{\"TEXT\": cond} for cond in (where_conditions or [])],\n                    \"ROWCOUNT\": chunk_size,\n                    \"ROWSKIPS\": skip_rows\n                }\n            })\n            \n            # Client-side processing\n            processed_chunk = self._process_table_chunk(chunk_result)\n            \n            if not processed_chunk[\"data\"]:\n                break  # No more data\n                \n            all_data.extend(processed_chunk[\"data\"])\n            rows_read += len(processed_chunk[\"data\"])\n            skip_rows += len(processed_chunk[\"data\"])\n            \n        return {\n            \"table_name\": table_name,\n            \"total_rows\": len(all_data),\n            \"data\": all_data,\n            \"processed_by\": \"client\"\n        }\n    \n    def _optimize_field_selection(self, table_name: str, fields: List[str]) -> List[str]:\n        \"\"\"Client-side field selection optimization.\"\"\"\n        # Remove duplicates, optimize order, etc.\n        return list(dict.fromkeys(fields))  # Remove duplicates preserving order\n    \n    def _optimize_where_conditions(self, conditions: List[str]) -> List[str]:\n        \"\"\"Client-side where clause optimization.\"\"\"\n        # Optimize conditions, remove redundancies, etc.\n        return conditions\n    \n    def _process_table_chunk(self, raw_result: Dict) -> Dict:\n        \"\"\"Process raw table data chunk.\"\"\"\n        # Client-side data processing\n        result_text = raw_result  # Simplified\n        \n        return {\n            \"data\": [],  # Processed data\n            \"fields\": [],  # Field metadata\n            \"processed_by\": \"client\"\n        }\n    \n    async def get_table_structure(self, table_name: str, language: str = \"EN\") -> Dict:\n        \"\"\"Get table structure with client-side caching.\"\"\"\n        # Use minimal server call and process client-side\n        raw_result = await self.mcp_client.call_tool(\"call_rfc_function\", {\n            \"function_name\": \"DDIF_FIELDINFO_GET\",\n            \"parameters\": {\n                \"TABNAME\": table_name,\n                \"LANGU\": language\n            }\n        })\n        \n        return self._process_table_structure(raw_result, table_name)\n    \n    def _process_table_structure(self, raw_result: Dict, table_name: str) -> Dict:\n        \"\"\"Process raw table structure data.\"\"\"\n        return {\n            \"table_name\": table_name,\n            \"fields\": [],  # Processed field information\n            \"processed_by\": \"client\"\n        }\n",
      "rfc_query_builder.py": "\"\"\"\nClient-side RFC Query Builder\nConstructs and validates RFC function calls.\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional\n\n\nclass RFCQueryBuilder:\n    \"\"\"Client-side RFC query construction and validation.\"\"\"\n    \n    def __init__(self, metadata_client=None):\n        self.metadata_client = metadata_client\n        \n    def build_rfc_call(self, \n                      function_name: str,\n                      parameters: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"Build validated RFC function call.\"\"\"\n        \n        # Client-side validation\n        if self.metadata_client:\n            metadata = self.metadata_client.get_cached_metadata(function_name)\n            if metadata:\n                parameters = self._validate_parameters(parameters or {}, metadata)\n        \n        return {\n            \"function_name\": function_name,\n            \"parameters\": parameters or {},\n            \"validated\": True\n        }\n    \n    def build_table_query(self,\n                         table_name: str,\n                         fields: List[str] = None,\n                         where_conditions: List[str] = None,\n                         max_rows: int = 100) -> Dict[str, Any]:\n        \"\"\"Build optimized table query.\"\"\"\n        \n        return {\n            \"function_name\": \"RFC_READ_TABLE\",\n            \"parameters\": {\n                \"QUERY_TABLE\": table_name,\n                \"DELIMITER\": \"|\",\n                \"FIELDS\": [{\"FIELDNAME\": f} for f in (fields or [])],\n                \"OPTIONS\": [{\"TEXT\": cond} for cond in (where_conditions or [])],\n                \"ROWCOUNT\": max_rows\n            }\n        }\n    \n    def _validate_parameters(self, parameters: Dict, metadata: Dict) -> Dict:\n        \"\"\"Validate parameters against function metadata.\"\"\"\n        # Client-side parameter validation\n        return parameters\n",
      "mcp_sap_client.py": "\"\"\"\nMCP SAP Client - High-level client for SAP RFC MCP server\nCombines minimal server calls with rich client-side processing.\n\"\"\"\n\nimport asyncio\nimport json\nimport subprocess\nfrom typing import Dict, List, Any, Optional\n\nfrom .rfc_metadata_client import RFCMetadataClient\nfrom .rfc_table_client import RFCTableClient\nfrom .rfc_query_builder import RFCQueryBuilder\n\n\nclass MCPSAPClient:\n    \"\"\"High-level client for SAP RFC operations via minimal MCP server.\"\"\"\n    \n    def __init__(self, server_command: List[str] = None):\n        self.server_command = server_command or [\n            \"python\", \"-m\", \"sap_rfc_mcp_server.minimal_server\"\n        ]\n        self.process = None\n        \n        # Client-side components\n        self.metadata = RFCMetadataClient(mcp_client=self)\n        self.tables = RFCTableClient(mcp_client=self)\n        self.query_builder = RFCQueryBuilder(metadata_client=self.metadata)\n        \n    async def connect(self):\n        \"\"\"Start MCP server process and establish connection.\"\"\"\n        self.process = await asyncio.create_subprocess_exec(\n            *self.server_command,\n            stdin=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n        \n        # Initialize MCP session\n        await self._send_mcp_request({\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"initialize\",\n            \"params\": {\n                \"protocolVersion\": \"2024-11-05\",\n                \"capabilities\": {\"roots\": {\"listChanged\": True}},\n                \"clientInfo\": {\"name\": \"sap-client\", \"version\": \"1.0.0\"}\n            }\n        })\n    \n    async def disconnect(self):\n        \"\"\"Disconnect from MCP server.\"\"\"\n        if self.process:\n            self.process.terminate()\n            await self.process.wait()\n    \n    async def call_tool(self, name: str, arguments: Dict = None) -> Any:\n        \"\"\"Call MCP tool on server.\"\"\"\n        response = await self._send_mcp_request({\n            \"jsonrpc\": \"2.0\",\n            \"id\": 2,\n            \"method\": \"tools/call\",\n            \"params\": {\n                \"name\": name,\n                \"arguments\": arguments or {}\n            }\n        })\n        \n        return response.get(\"result\", {})\n    \n    async def call_rfc_function(self, function_name: str, **parameters) -> Dict:\n        \"\"\"High-level RFC function call with client-side optimization.\"\"\"\n        \n        # Use query builder for validation\n        query = self.query_builder.build_rfc_call(function_name, parameters)\n        \n        # Call minimal server\n        result = await self.call_tool(\"call_rfc_function\", {\n            \"function_name\": query[\"function_name\"],\n            \"parameters\": query[\"parameters\"]\n        })\n        \n        return result\n    \n    async def read_table(self, table_name: str, **kwargs) -> Dict:\n        \"\"\"High-level table reading with client-side optimization.\"\"\"\n        return await self.tables.read_table_smart(table_name, **kwargs)\n    \n    async def get_function_metadata(self, function_name: str, language: str = \"EN\") -> Dict:\n        \"\"\"Get function metadata with client-side caching.\"\"\"\n        return await self.metadata.get_function_metadata(function_name, language)\n    \n    async def search_functions(self, query: str, limit: int = 20) -> List[Dict]:\n        \"\"\"Search functions using client-side index.\"\"\"\n        return self.metadata.search_functions(query, limit)\n    \n    async def _send_mcp_request(self, request: Dict) -> Dict:\n        \"\"\"Send MCP request to server and get response.\"\"\"\n        if not self.process:\n            raise RuntimeError(\"Not connected to server\")\n            \n        # Send request\n        request_data = json.dumps(request) + \"\\n\"\n        self.process.stdin.write(request_data.encode())\n        await self.process.stdin.drain()\n        \n        # Read response\n        response_data = await self.process.stdout.readline()\n        return json.loads(response_data.decode())\n"
    }
  }
}